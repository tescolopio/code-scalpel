"""
Code Scalpel Vulnerability Detection Benchmark Suite
=====================================================

Contains 120 test cases across 12 CWE vulnerability types.
Each CWE has 10 examples: 5 vulnerable + 5 safe patterns.

This benchmark validates:
1. Detection accuracy (true positives)
2. False positive rate (avoiding false alarms)
3. Cross-file taint tracking capabilities
"""

# =============================================================================
# CWE-89: SQL Injection (10 cases)
# =============================================================================

CWE_89_SQL_INJECTION = {
    "name": "SQL Injection",
    "cwe_id": "CWE-89",
    "description": "Improper neutralization of special elements used in SQL commands",
    "test_cases": [
        # VULNERABLE CASES (should detect)
        {
            "id": "CWE89-001",
            "name": "Direct string concatenation in query",
            "vulnerable": True,
            "code": '''
def get_user(username):
    query = "SELECT * FROM users WHERE name = '" + username + "'"
    cursor.execute(query)
    return cursor.fetchone()
''',
            "source": "username (function parameter)",
            "sink": "cursor.execute()",
            "expected_line": 3
        },
        {
            "id": "CWE89-002",
            "name": "F-string SQL injection",
            "vulnerable": True,
            "code": '''
def search_products(search_term):
    query = f"SELECT * FROM products WHERE name LIKE '%{search_term}%'"
    db.execute(query)
    return db.fetchall()
''',
            "source": "search_term (function parameter)",
            "sink": "db.execute()",
            "expected_line": 3
        },
        {
            "id": "CWE89-003",
            "name": "Format string SQL injection",
            "vulnerable": True,
            "code": '''
def delete_order(order_id):
    query = "DELETE FROM orders WHERE id = %s" % order_id
    connection.execute(query)
''',
            "source": "order_id (function parameter)",
            "sink": "connection.execute()",
            "expected_line": 3
        },
        {
            "id": "CWE89-004",
            "name": "Multi-hop taint flow",
            "vulnerable": True,
            "code": '''
def process_input(user_input):
    sanitized = user_input.strip()  # Not real sanitization!
    formatted = "id=" + sanitized
    query = "SELECT * FROM data WHERE " + formatted
    cursor.execute(query)
''',
            "source": "user_input (function parameter)",
            "sink": "cursor.execute()",
            "expected_line": 5
        },
        {
            "id": "CWE89-005",
            "name": "SQLAlchemy text() injection",
            "vulnerable": True,
            "code": '''
from sqlalchemy import text

def find_by_email(email):
    stmt = text("SELECT * FROM users WHERE email = '" + email + "'")
    session.execute(stmt)
''',
            "source": "email (function parameter)",
            "sink": "session.execute()",
            "expected_line": 5
        },
        # SAFE CASES (should NOT detect)
        {
            "id": "CWE89-006",
            "name": "Parameterized query",
            "vulnerable": False,
            "code": '''
def get_user_safe(username):
    query = "SELECT * FROM users WHERE name = ?"
    cursor.execute(query, (username,))
    return cursor.fetchone()
''',
            "source": "username (function parameter)",
            "sink": "cursor.execute() with params",
            "expected_line": None
        },
        {
            "id": "CWE89-007",
            "name": "SQLAlchemy ORM safe",
            "vulnerable": False,
            "code": '''
def get_user_orm(username):
    return User.query.filter_by(name=username).first()
''',
            "source": "username (function parameter)",
            "sink": "ORM filter (safe)",
            "expected_line": None
        },
        {
            "id": "CWE89-008",
            "name": "Named parameters",
            "vulnerable": False,
            "code": '''
def search_safe(term):
    query = "SELECT * FROM items WHERE name = :term"
    cursor.execute(query, {"term": term})
''',
            "source": "term (function parameter)",
            "sink": "cursor.execute() with named params",
            "expected_line": None
        },
        {
            "id": "CWE89-009",
            "name": "Hardcoded query",
            "vulnerable": False,
            "code": '''
def get_all_users():
    query = "SELECT * FROM users WHERE active = 1"
    cursor.execute(query)
    return cursor.fetchall()
''',
            "source": "None (hardcoded)",
            "sink": "cursor.execute()",
            "expected_line": None
        },
        {
            "id": "CWE89-010",
            "name": "Integer cast sanitization",
            "vulnerable": False,
            "code": '''
def get_by_id(user_id):
    safe_id = int(user_id)  # Cast sanitizes
    query = f"SELECT * FROM users WHERE id = {safe_id}"
    cursor.execute(query)
''',
            "source": "user_id (function parameter)",
            "sink": "cursor.execute() - int cast",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-79: Cross-Site Scripting (XSS) (10 cases)
# =============================================================================

CWE_79_XSS = {
    "name": "Cross-Site Scripting (XSS)",
    "cwe_id": "CWE-79",
    "description": "Improper neutralization of input during web page generation",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE79-001",
            "name": "Direct HTML concatenation",
            "vulnerable": True,
            "code": '''
def greet(name):
    return "<h1>Hello, " + name + "!</h1>"
''',
            "source": "name (function parameter)",
            "sink": "HTML string return",
            "expected_line": 2
        },
        {
            "id": "CWE79-002",
            "name": "Flask render_template_string injection",
            "vulnerable": True,
            "code": '''
from flask import render_template_string, request

def render_page():
    user_input = request.args.get('content')
    return render_template_string("<div>" + user_input + "</div>")
''',
            "source": "request.args.get()",
            "sink": "render_template_string()",
            "expected_line": 5
        },
        {
            "id": "CWE79-003",
            "name": "Response with unescaped content",
            "vulnerable": True,
            "code": '''
from flask import Response, request

def api_response():
    callback = request.args.get('callback')
    data = '{"status": "ok"}'
    return Response(callback + "(" + data + ")", mimetype='text/javascript')
''',
            "source": "request.args.get('callback')",
            "sink": "Response()",
            "expected_line": 6
        },
        {
            "id": "CWE79-004",
            "name": "Jinja2 safe filter misuse",
            "vulnerable": True,
            "code": '''
from markupsafe import Markup

def render_user_content(content):
    # Developer incorrectly marks user input as safe
    return Markup("<div>" + content + "</div>")
''',
            "source": "content (function parameter)",
            "sink": "Markup()",
            "expected_line": 5
        },
        {
            "id": "CWE79-005",
            "name": "DOM-based XSS pattern",
            "vulnerable": True,
            "code": '''
def build_page(user_data):
    html = f"""
    <html>
    <body>
        <script>document.write('{user_data}')</script>
    </body>
    </html>
    """
    return html
''',
            "source": "user_data (function parameter)",
            "sink": "document.write() in script",
            "expected_line": 5
        },
        # SAFE CASES
        {
            "id": "CWE79-006",
            "name": "Proper HTML escaping",
            "vulnerable": False,
            "code": '''
from markupsafe import escape

def greet_safe(name):
    return "<h1>Hello, " + escape(name) + "!</h1>"
''',
            "source": "name (function parameter)",
            "sink": "HTML with escape()",
            "expected_line": None
        },
        {
            "id": "CWE79-007",
            "name": "Jinja2 autoescaping",
            "vulnerable": False,
            "code": '''
from flask import render_template

def render_page_safe(user_name):
    return render_template('greeting.html', name=user_name)
''',
            "source": "user_name (function parameter)",
            "sink": "render_template() (auto-escaped)",
            "expected_line": None
        },
        {
            "id": "CWE79-008",
            "name": "JSON response (not HTML)",
            "vulnerable": False,
            "code": '''
import json
from flask import Response

def api_json(user_data):
    return Response(json.dumps({"data": user_data}), mimetype='application/json')
''',
            "source": "user_data (function parameter)",
            "sink": "JSON Response",
            "expected_line": None
        },
        {
            "id": "CWE79-009",
            "name": "Whitelist validation",
            "vulnerable": False,
            "code": '''
ALLOWED_VALUES = ['option1', 'option2', 'option3']

def render_option(value):
    if value not in ALLOWED_VALUES:
        value = 'option1'
    return f"<select><option selected>{value}</option></select>"
''',
            "source": "value (validated)",
            "sink": "HTML after whitelist check",
            "expected_line": None
        },
        {
            "id": "CWE79-010",
            "name": "Static content only",
            "vulnerable": False,
            "code": '''
def get_static_page():
    return "<html><body><h1>Welcome!</h1></body></html>"
''',
            "source": "None (static)",
            "sink": "HTML (no user data)",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-78: OS Command Injection (10 cases)
# =============================================================================

CWE_78_COMMAND_INJECTION = {
    "name": "Command Injection",
    "cwe_id": "CWE-78",
    "description": "Improper neutralization of special elements used in OS commands",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE78-001",
            "name": "os.system with user input",
            "vulnerable": True,
            "code": '''
import os

def ping_host(hostname):
    os.system("ping -c 4 " + hostname)
''',
            "source": "hostname (function parameter)",
            "sink": "os.system()",
            "expected_line": 4
        },
        {
            "id": "CWE78-002",
            "name": "subprocess shell=True",
            "vulnerable": True,
            "code": '''
import subprocess

def find_files(pattern):
    subprocess.run(f"find /tmp -name '{pattern}'", shell=True)
''',
            "source": "pattern (function parameter)",
            "sink": "subprocess.run(shell=True)",
            "expected_line": 4
        },
        {
            "id": "CWE78-003",
            "name": "subprocess.Popen with shell",
            "vulnerable": True,
            "code": '''
import subprocess

def get_user_processes(username):
    cmd = "ps aux | grep " + username
    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    return proc.communicate()[0]
''',
            "source": "username (function parameter)",
            "sink": "subprocess.Popen(shell=True)",
            "expected_line": 5
        },
        {
            "id": "CWE78-004",
            "name": "os.popen command injection",
            "vulnerable": True,
            "code": '''
import os

def list_directory(path):
    return os.popen("ls -la " + path).read()
''',
            "source": "path (function parameter)",
            "sink": "os.popen()",
            "expected_line": 4
        },
        {
            "id": "CWE78-005",
            "name": "eval with command construction",
            "vulnerable": True,
            "code": '''
import os

def dynamic_command(cmd_name, arg):
    full_cmd = f"{cmd_name} {arg}"
    os.system(full_cmd)
''',
            "source": "cmd_name, arg (function parameters)",
            "sink": "os.system()",
            "expected_line": 5
        },
        # SAFE CASES
        {
            "id": "CWE78-006",
            "name": "subprocess without shell",
            "vulnerable": False,
            "code": '''
import subprocess

def ping_safe(hostname):
    subprocess.run(["ping", "-c", "4", hostname])
''',
            "source": "hostname (function parameter)",
            "sink": "subprocess.run() without shell",
            "expected_line": None
        },
        {
            "id": "CWE78-007",
            "name": "shlex.quote sanitization",
            "vulnerable": False,
            "code": '''
import subprocess
import shlex

def find_safe(pattern):
    safe_pattern = shlex.quote(pattern)
    subprocess.run(f"find /tmp -name {safe_pattern}", shell=True)
''',
            "source": "pattern (function parameter)",
            "sink": "subprocess.run() with shlex.quote",
            "expected_line": None
        },
        {
            "id": "CWE78-008",
            "name": "Whitelist command validation",
            "vulnerable": False,
            "code": '''
import subprocess

ALLOWED_COMMANDS = ['ls', 'pwd', 'whoami']

def run_command(cmd):
    if cmd not in ALLOWED_COMMANDS:
        raise ValueError("Command not allowed")
    subprocess.run([cmd])
''',
            "source": "cmd (validated against whitelist)",
            "sink": "subprocess.run()",
            "expected_line": None
        },
        {
            "id": "CWE78-009",
            "name": "Hardcoded command",
            "vulnerable": False,
            "code": '''
import subprocess

def get_disk_usage():
    return subprocess.run(["df", "-h"], capture_output=True, text=True)
''',
            "source": "None (hardcoded)",
            "sink": "subprocess.run()",
            "expected_line": None
        },
        {
            "id": "CWE78-010",
            "name": "Path-only parameter (no shell)",
            "vulnerable": False,
            "code": '''
import subprocess
import os

def cat_file(filepath):
    if os.path.isfile(filepath):
        return subprocess.run(["cat", filepath], capture_output=True)
''',
            "source": "filepath (function parameter)",
            "sink": "subprocess.run() array form",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-22: Path Traversal (10 cases)
# =============================================================================

CWE_22_PATH_TRAVERSAL = {
    "name": "Path Traversal",
    "cwe_id": "CWE-22",
    "description": "Improper limitation of pathname to restricted directory",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE22-001",
            "name": "Direct file path from user",
            "vulnerable": True,
            "code": '''
def read_file(filename):
    with open("/var/data/" + filename, 'r') as f:
        return f.read()
''',
            "source": "filename (function parameter)",
            "sink": "open()",
            "expected_line": 2
        },
        {
            "id": "CWE22-002",
            "name": "os.path.join bypass",
            "vulnerable": True,
            "code": '''
import os

def get_document(doc_name):
    # os.path.join doesn't prevent absolute path injection
    path = os.path.join("/documents", doc_name)
    return open(path).read()
''',
            "source": "doc_name (function parameter)",
            "sink": "open()",
            "expected_line": 6
        },
        {
            "id": "CWE22-003",
            "name": "Flask send_file traversal",
            "vulnerable": True,
            "code": '''
from flask import send_file, request

def download():
    filename = request.args.get('file')
    return send_file('/uploads/' + filename)
''',
            "source": "request.args.get('file')",
            "sink": "send_file()",
            "expected_line": 5
        },
        {
            "id": "CWE22-004",
            "name": "Pathlib without validation",
            "vulnerable": True,
            "code": '''
from pathlib import Path

def load_config(config_name):
    config_path = Path("/etc/app") / config_name
    return config_path.read_text()
''',
            "source": "config_name (function parameter)",
            "sink": "Path.read_text()",
            "expected_line": 5
        },
        {
            "id": "CWE22-005",
            "name": "Double-encoded path traversal",
            "vulnerable": True,
            "code": '''
import urllib.parse

def fetch_resource(encoded_path):
    decoded = urllib.parse.unquote(encoded_path)
    with open("/resources/" + decoded) as f:
        return f.read()
''',
            "source": "encoded_path (function parameter)",
            "sink": "open()",
            "expected_line": 5
        },
        # SAFE CASES
        {
            "id": "CWE22-006",
            "name": "Basename sanitization",
            "vulnerable": False,
            "code": '''
import os

def read_file_safe(filename):
    safe_name = os.path.basename(filename)
    path = os.path.join("/var/data/", safe_name)
    with open(path, 'r') as f:
        return f.read()
''',
            "source": "filename (sanitized with basename)",
            "sink": "open()",
            "expected_line": None
        },
        {
            "id": "CWE22-007",
            "name": "Realpath check",
            "vulnerable": False,
            "code": '''
import os

SAFE_DIR = "/var/data/"

def read_validated(filename):
    full_path = os.path.realpath(os.path.join(SAFE_DIR, filename))
    if not full_path.startswith(SAFE_DIR):
        raise ValueError("Path traversal detected")
    return open(full_path).read()
''',
            "source": "filename (validated with realpath)",
            "sink": "open()",
            "expected_line": None
        },
        {
            "id": "CWE22-008",
            "name": "Flask safe_join",
            "vulnerable": False,
            "code": '''
from werkzeug.utils import safe_join
from flask import send_file

def download_safe(filename):
    safe_path = safe_join('/uploads', filename)
    if safe_path is None:
        return "Invalid path", 400
    return send_file(safe_path)
''',
            "source": "filename (safe_join validated)",
            "sink": "send_file()",
            "expected_line": None
        },
        {
            "id": "CWE22-009",
            "name": "UUID-based filename",
            "vulnerable": False,
            "code": '''
import uuid

FILES = {}  # uuid -> actual_path mapping

def get_file(file_id):
    try:
        uuid.UUID(file_id)  # Validates format
        return open(FILES.get(file_id)).read()
    except (ValueError, TypeError):
        return None
''',
            "source": "file_id (UUID validated)",
            "sink": "open()",
            "expected_line": None
        },
        {
            "id": "CWE22-010",
            "name": "Whitelist validation",
            "vulnerable": False,
            "code": '''
ALLOWED_FILES = ['readme.txt', 'license.txt', 'help.txt']

def read_allowed(filename):
    if filename not in ALLOWED_FILES:
        raise ValueError("File not allowed")
    return open(f"/docs/{filename}").read()
''',
            "source": "filename (whitelist validated)",
            "sink": "open()",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-918: Server-Side Request Forgery (SSRF) (10 cases)
# =============================================================================

CWE_918_SSRF = {
    "name": "Server-Side Request Forgery (SSRF)",
    "cwe_id": "CWE-918",
    "description": "Server-side request forgery allowing access to internal resources",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE918-001",
            "name": "Direct URL fetch",
            "vulnerable": True,
            "code": '''
import requests

def fetch_url(url):
    response = requests.get(url)
    return response.text
''',
            "source": "url (function parameter)",
            "sink": "requests.get()",
            "expected_line": 4
        },
        {
            "id": "CWE918-002",
            "name": "urllib request",
            "vulnerable": True,
            "code": '''
import urllib.request

def download_page(target_url):
    return urllib.request.urlopen(target_url).read()
''',
            "source": "target_url (function parameter)",
            "sink": "urllib.request.urlopen()",
            "expected_line": 4
        },
        {
            "id": "CWE918-003",
            "name": "URL from user parameter",
            "vulnerable": True,
            "code": '''
import requests
from flask import request

def proxy_request():
    target = request.args.get('url')
    return requests.get(target).text
''',
            "source": "request.args.get('url')",
            "sink": "requests.get()",
            "expected_line": 6
        },
        {
            "id": "CWE918-004",
            "name": "Image URL fetch",
            "vulnerable": True,
            "code": '''
import requests

def fetch_avatar(avatar_url):
    response = requests.get(avatar_url, timeout=10)
    return response.content
''',
            "source": "avatar_url (function parameter)",
            "sink": "requests.get()",
            "expected_line": 4
        },
        {
            "id": "CWE918-005",
            "name": "Webhook URL",
            "vulnerable": True,
            "code": '''
import requests

def trigger_webhook(webhook_url, payload):
    requests.post(webhook_url, json=payload)
''',
            "source": "webhook_url (function parameter)",
            "sink": "requests.post()",
            "expected_line": 4
        },
        # SAFE CASES
        {
            "id": "CWE918-006",
            "name": "Domain whitelist",
            "vulnerable": False,
            "code": '''
import requests
from urllib.parse import urlparse

ALLOWED_DOMAINS = ['api.example.com', 'cdn.example.com']

def fetch_safe(url):
    parsed = urlparse(url)
    if parsed.netloc not in ALLOWED_DOMAINS:
        raise ValueError("Domain not allowed")
    return requests.get(url).text
''',
            "source": "url (domain whitelist validated)",
            "sink": "requests.get()",
            "expected_line": None
        },
        {
            "id": "CWE918-007",
            "name": "Internal IP check",
            "vulnerable": False,
            "code": '''
import requests
import ipaddress
import socket
from urllib.parse import urlparse

def is_internal(url):
    parsed = urlparse(url)
    ip = socket.gethostbyname(parsed.hostname)
    return ipaddress.ip_address(ip).is_private

def fetch_external_only(url):
    if is_internal(url):
        raise ValueError("Internal URLs not allowed")
    return requests.get(url).text
''',
            "source": "url (internal IP check)",
            "sink": "requests.get()",
            "expected_line": None
        },
        {
            "id": "CWE918-008",
            "name": "Hardcoded URL",
            "vulnerable": False,
            "code": '''
import requests

API_URL = "https://api.example.com/data"

def fetch_api_data():
    return requests.get(API_URL).json()
''',
            "source": "None (hardcoded)",
            "sink": "requests.get()",
            "expected_line": None
        },
        {
            "id": "CWE918-009",
            "name": "URL construction with safe base",
            "vulnerable": False,
            "code": '''
import requests

BASE_URL = "https://api.github.com"

def get_repo(repo_name):
    # Only path is user-controlled, not the domain
    safe_path = repo_name.replace('..', '').replace('://', '')
    return requests.get(f"{BASE_URL}/repos/{safe_path}").json()
''',
            "source": "repo_name (path only, sanitized)",
            "sink": "requests.get()",
            "expected_line": None
        },
        {
            "id": "CWE918-010",
            "name": "Pre-registered URLs only",
            "vulnerable": False,
            "code": '''
import requests

REGISTERED_WEBHOOKS = {}  # user_id -> verified_url

def call_webhook(user_id, data):
    url = REGISTERED_WEBHOOKS.get(user_id)
    if url:
        requests.post(url, json=data)
''',
            "source": "url (from pre-registered mapping)",
            "sink": "requests.post()",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-327: Weak Cryptography (10 cases)
# =============================================================================

CWE_327_WEAK_CRYPTO = {
    "name": "Weak Cryptography",
    "cwe_id": "CWE-327",
    "description": "Use of broken or risky cryptographic algorithms",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE327-001",
            "name": "MD5 for password hashing",
            "vulnerable": True,
            "code": '''
import hashlib

def hash_password(password):
    return hashlib.md5(password.encode()).hexdigest()
''',
            "source": "password (function parameter)",
            "sink": "hashlib.md5()",
            "expected_line": 4
        },
        {
            "id": "CWE327-002",
            "name": "SHA1 for security",
            "vulnerable": True,
            "code": '''
import hashlib

def create_token(secret):
    return hashlib.sha1(secret.encode()).hexdigest()
''',
            "source": "secret (function parameter)",
            "sink": "hashlib.sha1()",
            "expected_line": 4
        },
        {
            "id": "CWE327-003",
            "name": "DES encryption",
            "vulnerable": True,
            "code": '''
from Crypto.Cipher import DES

def encrypt_data(key, data):
    cipher = DES.new(key, DES.MODE_ECB)
    return cipher.encrypt(data)
''',
            "source": "key, data (function parameters)",
            "sink": "DES.new()",
            "expected_line": 4
        },
        {
            "id": "CWE327-004",
            "name": "ECB mode usage",
            "vulnerable": True,
            "code": '''
from Crypto.Cipher import AES

def encrypt_ecb(key, data):
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.encrypt(data)
''',
            "source": "key, data (function parameters)",
            "sink": "AES.new(MODE_ECB)",
            "expected_line": 4
        },
        {
            "id": "CWE327-005",
            "name": "Weak random for crypto",
            "vulnerable": True,
            "code": '''
import random
import string

def generate_token():
    return ''.join(random.choices(string.ascii_letters, k=32))
''',
            "source": "random.choices (weak PRNG)",
            "sink": "token generation",
            "expected_line": 5
        },
        # SAFE CASES
        {
            "id": "CWE327-006",
            "name": "bcrypt password hashing",
            "vulnerable": False,
            "code": '''
import bcrypt

def hash_password_safe(password):
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt())
''',
            "source": "password (function parameter)",
            "sink": "bcrypt.hashpw()",
            "expected_line": None
        },
        {
            "id": "CWE327-007",
            "name": "SHA256 for integrity",
            "vulnerable": False,
            "code": '''
import hashlib

def compute_checksum(data):
    return hashlib.sha256(data).hexdigest()
''',
            "source": "data (function parameter)",
            "sink": "hashlib.sha256()",
            "expected_line": None
        },
        {
            "id": "CWE327-008",
            "name": "AES-GCM encryption",
            "vulnerable": False,
            "code": '''
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

def encrypt_safe(key, data):
    cipher = AES.new(key, AES.MODE_GCM)
    ciphertext, tag = cipher.encrypt_and_digest(data)
    return cipher.nonce + tag + ciphertext
''',
            "source": "key, data (function parameters)",
            "sink": "AES.new(MODE_GCM)",
            "expected_line": None
        },
        {
            "id": "CWE327-009",
            "name": "secrets module for tokens",
            "vulnerable": False,
            "code": '''
import secrets

def generate_token_safe():
    return secrets.token_hex(32)
''',
            "source": "secrets module (CSPRNG)",
            "sink": "secrets.token_hex()",
            "expected_line": None
        },
        {
            "id": "CWE327-010",
            "name": "Argon2 password hashing",
            "vulnerable": False,
            "code": '''
from argon2 import PasswordHasher

ph = PasswordHasher()

def hash_password_argon2(password):
    return ph.hash(password)
''',
            "source": "password (function parameter)",
            "sink": "PasswordHasher.hash()",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-502: Insecure Deserialization (10 cases)
# =============================================================================

CWE_502_DESERIALIZATION = {
    "name": "Insecure Deserialization",
    "cwe_id": "CWE-502",
    "description": "Deserialization of untrusted data leading to code execution",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE502-001",
            "name": "pickle.loads on user data",
            "vulnerable": True,
            "code": '''
import pickle

def load_session(data):
    return pickle.loads(data)
''',
            "source": "data (function parameter)",
            "sink": "pickle.loads()",
            "expected_line": 4
        },
        {
            "id": "CWE502-002",
            "name": "yaml.load without Loader",
            "vulnerable": True,
            "code": '''
import yaml

def parse_config(yaml_string):
    return yaml.load(yaml_string)
''',
            "source": "yaml_string (function parameter)",
            "sink": "yaml.load()",
            "expected_line": 4
        },
        {
            "id": "CWE502-003",
            "name": "yaml.load with Loader=Loader",
            "vulnerable": True,
            "code": '''
import yaml

def parse_yaml(content):
    return yaml.load(content, Loader=yaml.Loader)
''',
            "source": "content (function parameter)",
            "sink": "yaml.load(Loader=yaml.Loader)",
            "expected_line": 4
        },
        {
            "id": "CWE502-004",
            "name": "marshal.loads",
            "vulnerable": True,
            "code": '''
import marshal

def load_code(bytecode):
    return marshal.loads(bytecode)
''',
            "source": "bytecode (function parameter)",
            "sink": "marshal.loads()",
            "expected_line": 4
        },
        {
            "id": "CWE502-005",
            "name": "shelve.open with user path",
            "vulnerable": True,
            "code": '''
import shelve

def load_shelf(shelf_path):
    with shelve.open(shelf_path) as db:
        return dict(db)
''',
            "source": "shelf_path (function parameter)",
            "sink": "shelve.open()",
            "expected_line": 4
        },
        # SAFE CASES
        {
            "id": "CWE502-006",
            "name": "json.loads (safe)",
            "vulnerable": False,
            "code": '''
import json

def parse_data(json_string):
    return json.loads(json_string)
''',
            "source": "json_string (function parameter)",
            "sink": "json.loads()",
            "expected_line": None
        },
        {
            "id": "CWE502-007",
            "name": "yaml.safe_load",
            "vulnerable": False,
            "code": '''
import yaml

def parse_yaml_safe(content):
    return yaml.safe_load(content)
''',
            "source": "content (function parameter)",
            "sink": "yaml.safe_load()",
            "expected_line": None
        },
        {
            "id": "CWE502-008",
            "name": "Pickle with HMAC verification",
            "vulnerable": False,
            "code": '''
import pickle
import hmac
import hashlib

SECRET_KEY = b'secret'

def load_verified(data, signature):
    expected_sig = hmac.new(SECRET_KEY, data, hashlib.sha256).digest()
    if not hmac.compare_digest(signature, expected_sig):
        raise ValueError("Invalid signature")
    return pickle.loads(data)
''',
            "source": "data (HMAC verified)",
            "sink": "pickle.loads()",
            "expected_line": None
        },
        {
            "id": "CWE502-009",
            "name": "Protocol buffers",
            "vulnerable": False,
            "code": '''
from google.protobuf import message_pb2

def parse_protobuf(data):
    msg = message_pb2.MyMessage()
    msg.ParseFromString(data)
    return msg
''',
            "source": "data (protobuf schema-bound)",
            "sink": "ParseFromString()",
            "expected_line": None
        },
        {
            "id": "CWE502-010",
            "name": "msgpack (safe by default)",
            "vulnerable": False,
            "code": '''
import msgpack

def parse_msgpack(data):
    return msgpack.unpackb(data, raw=False)
''',
            "source": "data (function parameter)",
            "sink": "msgpack.unpackb()",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-94: Code Injection (10 cases)
# =============================================================================

CWE_94_CODE_INJECTION = {
    "name": "Code Injection",
    "cwe_id": "CWE-94",
    "description": "Improper control of code generation allowing arbitrary code execution",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE94-001",
            "name": "eval() on user input",
            "vulnerable": True,
            "code": '''
def calculate(expression):
    return eval(expression)
''',
            "source": "expression (function parameter)",
            "sink": "eval()",
            "expected_line": 2
        },
        {
            "id": "CWE94-002",
            "name": "exec() on user code",
            "vulnerable": True,
            "code": '''
def run_script(code):
    exec(code)
''',
            "source": "code (function parameter)",
            "sink": "exec()",
            "expected_line": 2
        },
        {
            "id": "CWE94-003",
            "name": "compile() with user input",
            "vulnerable": True,
            "code": '''
def compile_and_run(source):
    code = compile(source, '<string>', 'exec')
    exec(code)
''',
            "source": "source (function parameter)",
            "sink": "compile()",
            "expected_line": 2
        },
        {
            "id": "CWE94-004",
            "name": "__import__ injection",
            "vulnerable": True,
            "code": '''
def dynamic_import(module_name):
    mod = __import__(module_name)
    return mod
''',
            "source": "module_name (function parameter)",
            "sink": "__import__()",
            "expected_line": 2
        },
        {
            "id": "CWE94-005",
            "name": "exec with f-string",
            "vulnerable": True,
            "code": '''
def create_class(class_name, method_body):
    code = f"""
class {class_name}:
    def method(self):
        {method_body}
"""
    exec(code)
''',
            "source": "class_name, method_body (function parameters)",
            "sink": "exec()",
            "expected_line": 7
        },
        # SAFE CASES
        {
            "id": "CWE94-006",
            "name": "ast.literal_eval (safe)",
            "vulnerable": False,
            "code": '''
import ast

def parse_literal(value):
    return ast.literal_eval(value)
''',
            "source": "value (function parameter)",
            "sink": "ast.literal_eval()",
            "expected_line": None
        },
        {
            "id": "CWE94-007",
            "name": "Restricted builtins eval",
            "vulnerable": False,
            "code": '''
SAFE_BUILTINS = {'abs': abs, 'min': min, 'max': max}

def safe_eval(expression):
    return eval(expression, {"__builtins__": SAFE_BUILTINS}, {})
''',
            "source": "expression (restricted eval)",
            "sink": "eval()",
            "expected_line": None
        },
        {
            "id": "CWE94-008",
            "name": "importlib with whitelist",
            "vulnerable": False,
            "code": '''
import importlib

ALLOWED_MODULES = ['json', 'datetime', 'collections']

def safe_import(module_name):
    if module_name not in ALLOWED_MODULES:
        raise ValueError("Module not allowed")
    return importlib.import_module(module_name)
''',
            "source": "module_name (whitelist validated)",
            "sink": "importlib.import_module()",
            "expected_line": None
        },
        {
            "id": "CWE94-009",
            "name": "Hardcoded eval",
            "vulnerable": False,
            "code": '''
def get_config_value():
    return eval("{'debug': True, 'version': 1}")
''',
            "source": "None (hardcoded)",
            "sink": "eval()",
            "expected_line": None
        },
        {
            "id": "CWE94-010",
            "name": "sympy sympify (math only)",
            "vulnerable": False,
            "code": '''
from sympy import sympify

def parse_math(expression):
    return sympify(expression, evaluate=False)
''',
            "source": "expression (math DSL)",
            "sink": "sympify()",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-798: Hardcoded Secrets (10 cases)
# =============================================================================

CWE_798_HARDCODED_SECRETS = {
    "name": "Hardcoded Secrets",
    "cwe_id": "CWE-798",
    "description": "Use of hard-coded credentials or secrets",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE798-001",
            "name": "Hardcoded AWS key",
            "vulnerable": True,
            "code": '''
AWS_ACCESS_KEY = "AKIAIOSFODNN7EXAMPLE"
AWS_SECRET_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"

def get_s3_client():
    import boto3
    return boto3.client('s3',
        aws_access_key_id=AWS_ACCESS_KEY,
        aws_secret_access_key=AWS_SECRET_KEY)
''',
            "source": "Hardcoded AWS credentials",
            "sink": "boto3.client()",
            "expected_line": 2
        },
        {
            "id": "CWE798-002",
            "name": "Hardcoded API key",
            "vulnerable": True,
            "code": '''
API_KEY = "AKIAIOSFODNN7EXAMPLE"

def make_request():
    import requests
    return requests.get("https://api.example.com",
                       headers={"Authorization": f"Bearer {API_KEY}"})
''',
            "source": "Hardcoded API key",
            "sink": "requests headers",
            "expected_line": 1
        },
        {
            "id": "CWE798-003",
            "name": "Hardcoded database password",
            "vulnerable": True,
            "code": '''
DB_PASSWORD = "super_secret_password123!"

def connect_db():
    import psycopg2
    return psycopg2.connect(
        host="localhost",
        password=DB_PASSWORD
    )
''',
            "source": "Hardcoded password",
            "sink": "psycopg2.connect()",
            "expected_line": 1
        },
        {
            "id": "CWE798-004",
            "name": "Hardcoded JWT secret",
            "vulnerable": True,
            "code": '''
import jwt

JWT_SECRET = "my-super-secret-key-12345"

def create_token(user_id):
    return jwt.encode({"user": user_id}, JWT_SECRET, algorithm="HS256")
''',
            "source": "Hardcoded JWT secret",
            "sink": "jwt.encode()",
            "expected_line": 3
        },
        {
            "id": "CWE798-005",
            "name": "Hardcoded private key",
            "vulnerable": True,
            "code": '''
PRIVATE_KEY = """-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA0Z3VS5JJcds3xfn/ygWyF8PbnGy...
-----END RSA PRIVATE KEY-----"""

def sign_data(data):
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import padding
    # ... signing logic
''',
            "source": "Hardcoded private key",
            "sink": "Cryptographic operation",
            "expected_line": 1
        },
        # SAFE CASES
        {
            "id": "CWE798-006",
            "name": "Environment variable",
            "vulnerable": False,
            "code": '''
import os

API_KEY = os.environ.get("API_KEY")

def make_request():
    import requests
    return requests.get("https://api.example.com",
                       headers={"Authorization": f"Bearer {API_KEY}"})
''',
            "source": "Environment variable",
            "sink": "requests headers",
            "expected_line": None
        },
        {
            "id": "CWE798-007",
            "name": "Config file loading",
            "vulnerable": False,
            "code": '''
import json

def get_credentials():
    with open('/etc/app/credentials.json') as f:
        return json.load(f)

creds = get_credentials()
''',
            "source": "Config file",
            "sink": "Variable assignment",
            "expected_line": None
        },
        {
            "id": "CWE798-008",
            "name": "AWS IAM role",
            "vulnerable": False,
            "code": '''
import boto3

def get_s3_client():
    # Uses IAM role, no hardcoded credentials
    return boto3.client('s3')
''',
            "source": "IAM role (implicit)",
            "sink": "boto3.client()",
            "expected_line": None
        },
        {
            "id": "CWE798-009",
            "name": "Secret manager",
            "vulnerable": False,
            "code": '''
import boto3

def get_secret(secret_name):
    client = boto3.client('secretsmanager')
    response = client.get_secret_value(SecretId=secret_name)
    return response['SecretString']
''',
            "source": "Secrets Manager",
            "sink": "Return value",
            "expected_line": None
        },
        {
            "id": "CWE798-010",
            "name": "Placeholder/example key",
            "vulnerable": False,
            "code": '''
# Example configuration - replace with real values
API_KEY = "YOUR_API_KEY_HERE"  # Placeholder
API_KEY = "<INSERT_KEY>"  # Also placeholder
API_KEY = "xxx"  # Test placeholder
''',
            "source": "Placeholder (not real)",
            "sink": "Variable assignment",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-90: LDAP Injection (10 cases)
# =============================================================================

CWE_90_LDAP_INJECTION = {
    "name": "LDAP Injection",
    "cwe_id": "CWE-90",
    "description": "Improper neutralization of special elements in LDAP queries",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE90-001",
            "name": "Direct LDAP filter injection",
            "vulnerable": True,
            "code": '''
import ldap

def find_user(username):
    conn = ldap.initialize("ldap://localhost")
    filter_str = f"(uid={username})"
    return conn.search_s("dc=example,dc=com", ldap.SCOPE_SUBTREE, filter_str)
''',
            "source": "username (function parameter)",
            "sink": "conn.search_s()",
            "expected_line": 6
        },
        {
            "id": "CWE90-002",
            "name": "LDAP authentication bypass",
            "vulnerable": True,
            "code": '''
import ldap

def authenticate(username, password):
    conn = ldap.initialize("ldap://localhost")
    dn = f"uid={username},ou=users,dc=example,dc=com"
    conn.simple_bind_s(dn, password)
''',
            "source": "username (function parameter)",
            "sink": "conn.simple_bind_s()",
            "expected_line": 5
        },
        {
            "id": "CWE90-003",
            "name": "LDAP search with concatenation",
            "vulnerable": True,
            "code": '''
import ldap

def search_employees(department):
    conn = ldap.initialize("ldap://localhost")
    query = "(&(objectClass=person)(department=" + department + "))"
    return conn.search_s("dc=company,dc=com", ldap.SCOPE_SUBTREE, query)
''',
            "source": "department (function parameter)",
            "sink": "conn.search_s()",
            "expected_line": 6
        },
        {
            "id": "CWE90-004",
            "name": "LDAP OR injection",
            "vulnerable": True,
            "code": '''
import ldap

def find_by_email(email):
    conn = ldap.initialize("ldap://localhost")
    search_filter = "(|(mail={0})(mailAlternate={0}))".format(email)
    return conn.search_s("dc=example,dc=com", ldap.SCOPE_SUBTREE, search_filter)
''',
            "source": "email (function parameter)",
            "sink": "conn.search_s()",
            "expected_line": 6
        },
        {
            "id": "CWE90-005",
            "name": "LDAP modify with user input",
            "vulnerable": True,
            "code": '''
import ldap

def update_description(user_dn, description):
    conn = ldap.initialize("ldap://localhost")
    mod_attrs = [(ldap.MOD_REPLACE, 'description', description.encode())]
    conn.modify_s(user_dn, mod_attrs)
''',
            "source": "user_dn (function parameter)",
            "sink": "conn.modify_s()",
            "expected_line": 6
        },
        # SAFE CASES
        {
            "id": "CWE90-006",
            "name": "LDAP filter escaping",
            "vulnerable": False,
            "code": '''
import ldap
from ldap.filter import escape_filter_chars

def find_user_safe(username):
    conn = ldap.initialize("ldap://localhost")
    safe_username = escape_filter_chars(username)
    filter_str = f"(uid={safe_username})"
    return conn.search_s("dc=example,dc=com", ldap.SCOPE_SUBTREE, filter_str)
''',
            "source": "username (escaped)",
            "sink": "conn.search_s()",
            "expected_line": None
        },
        {
            "id": "CWE90-007",
            "name": "Parameterized LDAP query",
            "vulnerable": False,
            "code": '''
import ldap
from ldap.filter import filter_format

def find_user_param(username):
    conn = ldap.initialize("ldap://localhost")
    filter_str = filter_format("(uid=%s)", (username,))
    return conn.search_s("dc=example,dc=com", ldap.SCOPE_SUBTREE, filter_str)
''',
            "source": "username (parameterized)",
            "sink": "conn.search_s()",
            "expected_line": None
        },
        {
            "id": "CWE90-008",
            "name": "Whitelist validation",
            "vulnerable": False,
            "code": '''
import ldap
import re

def find_by_dept(department):
    if not re.match(r'^[a-zA-Z]+$', department):
        raise ValueError("Invalid department name")
    conn = ldap.initialize("ldap://localhost")
    return conn.search_s("dc=example,dc=com", ldap.SCOPE_SUBTREE,
                        f"(department={department})")
''',
            "source": "department (regex validated)",
            "sink": "conn.search_s()",
            "expected_line": None
        },
        {
            "id": "CWE90-009",
            "name": "Hardcoded LDAP query",
            "vulnerable": False,
            "code": '''
import ldap

def get_all_users():
    conn = ldap.initialize("ldap://localhost")
    return conn.search_s("dc=example,dc=com", ldap.SCOPE_SUBTREE,
                        "(objectClass=person)")
''',
            "source": "None (hardcoded)",
            "sink": "conn.search_s()",
            "expected_line": None
        },
        {
            "id": "CWE90-010",
            "name": "DN escaping",
            "vulnerable": False,
            "code": '''
import ldap
from ldap.dn import escape_dn_chars

def authenticate_safe(username, password):
    conn = ldap.initialize("ldap://localhost")
    safe_username = escape_dn_chars(username)
    dn = f"uid={safe_username},ou=users,dc=example,dc=com"
    conn.simple_bind_s(dn, password)
''',
            "source": "username (DN escaped)",
            "sink": "conn.simple_bind_s()",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-91: XML Injection (10 cases)
# =============================================================================

CWE_91_XML_INJECTION = {
    "name": "XML Injection",
    "cwe_id": "CWE-91",
    "description": "XML injection including XXE (XML External Entity) attacks",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE91-001",
            "name": "XML parsing without disabling entities",
            "vulnerable": True,
            "code": '''
from xml.etree.ElementTree import parse

def parse_xml(xml_file):
    tree = parse(xml_file)
    return tree.getroot()
''',
            "source": "xml_file (function parameter)",
            "sink": "parse()",
            "expected_line": 4
        },
        {
            "id": "CWE91-002",
            "name": "lxml with entity resolution",
            "vulnerable": True,
            "code": '''
from lxml import etree

def parse_xml_lxml(xml_string):
    parser = etree.XMLParser(resolve_entities=True)
    return etree.fromstring(xml_string, parser)
''',
            "source": "xml_string (function parameter)",
            "sink": "etree.fromstring()",
            "expected_line": 5
        },
        {
            "id": "CWE91-003",
            "name": "xml.dom.minidom parsing",
            "vulnerable": True,
            "code": '''
from xml.dom.minidom import parseString

def parse_dom(xml_data):
    return parseString(xml_data)
''',
            "source": "xml_data (function parameter)",
            "sink": "parseString()",
            "expected_line": 4
        },
        {
            "id": "CWE91-004",
            "name": "SAX parser without feature restriction",
            "vulnerable": True,
            "code": '''
import xml.sax

def parse_sax(xml_file, handler):
    parser = xml.sax.make_parser()
    parser.setContentHandler(handler)
    parser.parse(xml_file)
''',
            "source": "xml_file (function parameter)",
            "sink": "parser.parse()",
            "expected_line": 6
        },
        {
            "id": "CWE91-005",
            "name": "XML string concatenation",
            "vulnerable": True,
            "code": '''
def create_xml_response(user_name, user_data):
    xml = f"""<?xml version="1.0"?>
    <response>
        <user>{user_name}</user>
        <data>{user_data}</data>
    </response>"""
    return xml
''',
            "source": "user_name, user_data (function parameters)",
            "sink": "XML string construction",
            "expected_line": 2
        },
        # SAFE CASES
        {
            "id": "CWE91-006",
            "name": "defusedxml parsing",
            "vulnerable": False,
            "code": '''
import defusedxml.ElementTree as ET

def parse_xml_safe(xml_string):
    return ET.fromstring(xml_string)
''',
            "source": "xml_string (function parameter)",
            "sink": "defusedxml.fromstring()",
            "expected_line": None
        },
        {
            "id": "CWE91-007",
            "name": "lxml with disabled entities",
            "vulnerable": False,
            "code": '''
from lxml import etree

def parse_lxml_safe(xml_string):
    parser = etree.XMLParser(resolve_entities=False, no_network=True)
    return etree.fromstring(xml_string, parser)
''',
            "source": "xml_string (function parameter)",
            "sink": "etree.fromstring() (safe parser)",
            "expected_line": None
        },
        {
            "id": "CWE91-008",
            "name": "XML builder (not parsing)",
            "vulnerable": False,
            "code": '''
from xml.etree.ElementTree import Element, SubElement, tostring

def build_xml(data):
    root = Element('response')
    for key, value in data.items():
        child = SubElement(root, key)
        child.text = str(value)
    return tostring(root)
''',
            "source": "data (function parameter)",
            "sink": "Element construction",
            "expected_line": None
        },
        {
            "id": "CWE91-009",
            "name": "SAX with disabled features",
            "vulnerable": False,
            "code": '''
import xml.sax

def parse_sax_safe(xml_file, handler):
    parser = xml.sax.make_parser()
    parser.setFeature(xml.sax.handler.feature_external_ges, False)
    parser.setFeature(xml.sax.handler.feature_external_pes, False)
    parser.setContentHandler(handler)
    parser.parse(xml_file)
''',
            "source": "xml_file (function parameter)",
            "sink": "parser.parse() (safe features)",
            "expected_line": None
        },
        {
            "id": "CWE91-010",
            "name": "JSON instead of XML",
            "vulnerable": False,
            "code": '''
import json

def create_response(user_name, user_data):
    return json.dumps({
        "user": user_name,
        "data": user_data
    })
''',
            "source": "user_name, user_data (function parameters)",
            "sink": "json.dumps()",
            "expected_line": None
        }
    ]
}

# =============================================================================
# CWE-113: HTTP Header Injection (10 cases)
# =============================================================================

CWE_113_HEADER_INJECTION = {
    "name": "HTTP Header Injection",
    "cwe_id": "CWE-113",
    "description": "Improper neutralization of CRLF sequences in HTTP headers",
    "test_cases": [
        # VULNERABLE CASES
        {
            "id": "CWE113-001",
            "name": "Set-Cookie with user input",
            "vulnerable": True,
            "code": '''
from flask import make_response, request

def set_preference():
    theme = request.args.get('theme')
    resp = make_response("OK")
    resp.headers['Set-Cookie'] = f"theme={theme}"
    return resp
''',
            "source": "request.args.get('theme')",
            "sink": "resp.headers['Set-Cookie']",
            "expected_line": 6
        },
        {
            "id": "CWE113-002",
            "name": "Location header redirect",
            "vulnerable": True,
            "code": '''
from flask import Response, request

def redirect():
    url = request.args.get('url')
    resp = Response(status=302)
    resp.headers['Location'] = url
    return resp
''',
            "source": "request.args.get('url')",
            "sink": "resp.headers['Location']",
            "expected_line": 6
        },
        {
            "id": "CWE113-003",
            "name": "Custom header injection",
            "vulnerable": True,
            "code": '''
from flask import Response, request

def api_response():
    request_id = request.headers.get('X-Request-ID')
    resp = Response('{"status": "ok"}')
    resp.headers['X-Request-ID'] = request_id
    return resp
''',
            "source": "request.headers.get('X-Request-ID')",
            "sink": "resp.headers['X-Request-ID']",
            "expected_line": 6
        },
        {
            "id": "CWE113-004",
            "name": "Content-Disposition filename",
            "vulnerable": True,
            "code": '''
from flask import Response, request

def download():
    filename = request.args.get('filename')
    resp = Response(b"file content")
    resp.headers['Content-Disposition'] = f'attachment; filename="{filename}"'
    return resp
''',
            "source": "request.args.get('filename')",
            "sink": "resp.headers['Content-Disposition']",
            "expected_line": 6
        },
        {
            "id": "CWE113-005",
            "name": "Multiple headers via dict update",
            "vulnerable": True,
            "code": '''
from flask import Response, request

def custom_response():
    custom_headers = request.json.get('headers', {})
    resp = Response("OK")
    resp.headers.update(custom_headers)
    return resp
''',
            "source": "request.json.get('headers')",
            "sink": "resp.headers.update()",
            "expected_line": 6
        },
        # SAFE CASES
        {
            "id": "CWE113-006",
            "name": "Sanitized header value",
            "vulnerable": False,
            "code": '''
from flask import make_response, request
import re

def set_preference_safe():
    theme = request.args.get('theme', 'light')
    # Remove any CRLF characters
    safe_theme = re.sub(r'[\\r\\n]', '', theme)
    resp = make_response("OK")
    resp.headers['Set-Cookie'] = f"theme={safe_theme}"
    return resp
''',
            "source": "request.args.get('theme') (sanitized)",
            "sink": "resp.headers['Set-Cookie']",
            "expected_line": None
        },
        {
            "id": "CWE113-007",
            "name": "Whitelist validation",
            "vulnerable": False,
            "code": '''
from flask import make_response, request

ALLOWED_THEMES = ['light', 'dark', 'system']

def set_theme_safe():
    theme = request.args.get('theme', 'light')
    if theme not in ALLOWED_THEMES:
        theme = 'light'
    resp = make_response("OK")
    resp.set_cookie('theme', theme)
    return resp
''',
            "source": "request.args.get('theme') (whitelist)",
            "sink": "resp.set_cookie()",
            "expected_line": None
        },
        {
            "id": "CWE113-008",
            "name": "Flask redirect helper",
            "vulnerable": False,
            "code": '''
from flask import redirect, request
from urllib.parse import urlparse

def safe_redirect():
    url = request.args.get('url', '/')
    # Validate URL is relative or same domain
    parsed = urlparse(url)
    if parsed.netloc and parsed.netloc != 'example.com':
        url = '/'
    return redirect(url)
''',
            "source": "request.args.get('url') (validated)",
            "sink": "redirect()",
            "expected_line": None
        },
        {
            "id": "CWE113-009",
            "name": "Hardcoded headers",
            "vulnerable": False,
            "code": '''
from flask import Response

def api_response():
    resp = Response('{"status": "ok"}')
    resp.headers['Content-Type'] = 'application/json'
    resp.headers['X-Content-Type-Options'] = 'nosniff'
    return resp
''',
            "source": "None (hardcoded)",
            "sink": "resp.headers",
            "expected_line": None
        },
        {
            "id": "CWE113-010",
            "name": "UUID-only request ID",
            "vulnerable": False,
            "code": '''
from flask import Response, request
import uuid

def traced_response():
    request_id = request.headers.get('X-Request-ID', '')
    # Validate it's a valid UUID
    try:
        uuid.UUID(request_id)
    except ValueError:
        request_id = str(uuid.uuid4())
    resp = Response('OK')
    resp.headers['X-Request-ID'] = request_id
    return resp
''',
            "source": "request.headers (UUID validated)",
            "sink": "resp.headers['X-Request-ID']",
            "expected_line": None
        }
    ]
}

# =============================================================================
# Aggregate all test cases
# =============================================================================

ALL_VULNERABILITY_CATEGORIES = [
    CWE_89_SQL_INJECTION,
    CWE_79_XSS,
    CWE_78_COMMAND_INJECTION,
    CWE_22_PATH_TRAVERSAL,
    CWE_918_SSRF,
    CWE_327_WEAK_CRYPTO,
    CWE_502_DESERIALIZATION,
    CWE_94_CODE_INJECTION,
    CWE_798_HARDCODED_SECRETS,
    CWE_90_LDAP_INJECTION,
    CWE_91_XML_INJECTION,
    CWE_113_HEADER_INJECTION,
]

def get_all_test_cases():
    """Return all 120 test cases as a flat list."""
    all_cases = []
    for category in ALL_VULNERABILITY_CATEGORIES:
        for case in category["test_cases"]:
            case["cwe_id"] = category["cwe_id"]
            case["category_name"] = category["name"]
            all_cases.append(case)
    return all_cases

def get_vulnerable_cases():
    """Return only vulnerable test cases (should be detected)."""
    return [c for c in get_all_test_cases() if c["vulnerable"]]

def get_safe_cases():
    """Return only safe test cases (should NOT be detected)."""
    return [c for c in get_all_test_cases() if not c["vulnerable"]]

def get_category_summary():
    """Return summary statistics by category."""
    summary = []
    for category in ALL_VULNERABILITY_CATEGORIES:
        vulnerable = sum(1 for c in category["test_cases"] if c["vulnerable"])
        safe = sum(1 for c in category["test_cases"] if not c["vulnerable"])
        summary.append({
            "cwe_id": category["cwe_id"],
            "name": category["name"],
            "vulnerable_cases": vulnerable,
            "safe_cases": safe,
            "total": len(category["test_cases"])
        })
    return summary


if __name__ == "__main__":
    # Print summary
    print("=" * 70)
    print("CODE SCALPEL VULNERABILITY DETECTION BENCHMARK SUITE")
    print("=" * 70)
    print()

    summary = get_category_summary()
    total_cases = 0
    total_vuln = 0
    total_safe = 0

    print(f"{'CWE ID':<10} {'Category':<35} {'Vuln':<6} {'Safe':<6} {'Total':<6}")
    print("-" * 70)

    for cat in summary:
        print(f"{cat['cwe_id']:<10} {cat['name']:<35} {cat['vulnerable_cases']:<6} {cat['safe_cases']:<6} {cat['total']:<6}")
        total_cases += cat['total']
        total_vuln += cat['vulnerable_cases']
        total_safe += cat['safe_cases']

    print("-" * 70)
    print(f"{'TOTAL':<10} {'':<35} {total_vuln:<6} {total_safe:<6} {total_cases:<6}")
    print()
    print(f"Total test cases: {total_cases}")
    print(f"Vulnerable cases (should detect): {total_vuln}")
    print(f"Safe cases (should NOT detect): {total_safe}")
